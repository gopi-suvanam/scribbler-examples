{
  "metadata": {
    "name": "Decision Trees",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "/**\n * Calculates the chi-squared statistic.\n * \n * @param {Float32Array} observed - Observed frequencies.\n * @param {Float32Array} expected - Expected frequencies.\n * @returns {number} Chi-squared statistic value.\n */\nfunction chiSquared(observed, expected) {\n  let chiSq = 0;\n  for (let i = 0; i < observed.length; i++) {\n    chiSq += Math.pow(observed[i] - expected[i], 2) / expected[i];\n  }\n  return chiSq;\n}\n\n/**\n * Calculates observed and expected frequencies for a given attribute and target.\n * \n * @param {Array<Object>} data - Dataset.\n * @param {string} attribute - Attribute to split data by.\n * @param {string} target - Target variable.\n * @returns {Object} Object containing observed frequencies, expected frequencies, and raw frequencies.\n */\nfunction getFrequencies(data, attribute, target) {\n  const attrValues = new Set(data.map(row => row[attribute]));\n  const targetValues = new Set(data.map(row => row[target]));\n\n  // Initialize frequency counters.\n  const frequencies = new Map();\n  const targetTotals = new Map();\n\n  // Count frequencies.\n  data.forEach(row => {\n    const attrValue = row[attribute];\n    const targetValue = row[target];\n\n    if (!frequencies.has(attrValue)) {\n      frequencies.set(attrValue, new Map());\n    }\n    if (!frequencies.get(attrValue).has(targetValue)) {\n      frequencies.get(attrValue).set(targetValue, 0);\n    }\n    frequencies.get(attrValue).set(targetValue, frequencies.get(attrValue).get(targetValue) + 1);\n\n    if (!targetTotals.has(targetValue)) {\n      targetTotals.set(targetValue, 0);\n    }\n    targetTotals.set(targetValue, targetTotals.get(targetValue) + 1);\n  });\n\n  // Initialize observed and expected frequencies as Float32Array.\n  const observed = new Float32Array(attrValues.size * targetValues.size);\n  const expected = new Float32Array(attrValues.size * targetValues.size);\n\n  let index = 0;\n  frequencies.forEach((targetMap, attrValue) => {\n    const total = Array.from(targetMap.values()).reduce((a, b) => a + b, 0);\n    targetValues.forEach(targetValue => {\n      const observedFreq = targetMap.get(targetValue) || 0;\n      const expectedFreq = (total * targetTotals.get(targetValue)) / data.length;\n      observed[index] = observedFreq;\n      expected[index] = expectedFreq;\n      index++;\n    });\n  });\n\n  return { observed, expected, frequencies };\n}\n\n/**\n * Calculates Bhattacharyya similarity coefficient between two probability distributions.\n * \n * @param {Float32Array} prob1 - First probability distribution.\n * @param {Float32Array} prob2 - Second probability distribution.\n * @returns {number} Bhattacharyya similarity coefficient (0 ≤ BC ≤ 1).\n */\nfunction bhattacharyyaSimilarity(prob1, prob2) {\n  let bc = 0;\n  for (let i = 0; i < prob1.length; i++) {\n    bc += Math.sqrt(prob1[i] * prob2[i]);\n  }\n  return bc;\n}\n\n/**\n * Finds the best attribute to split a node in a decision tree.\n * \n * @param {Array<Object>} data - Dataset.\n * @param {Array<string>} attributes - Available attributes.\n * @param {string} target - Target variable.\n * @returns {Object} Object containing best attribute, merged frequencies, and chi-squared statistic.\n */\nfunction findBestSplit(data, attributes, target) {\n  let bestAttribute = null;\n  let bestChiSq = 0;\n  let bestFrequencies = {};\n\n  attributes.forEach(attribute => {\n    const { observed, expected, frequencies } = getFrequencies(data, attribute, target);\n    const chiSq = chiSquared(observed, expected);\n\n    if (chiSq > bestChiSq) {\n      bestChiSq = chiSq;\n      bestFrequencies = mergeCategories(frequencies);\n      bestAttribute = attribute;\n    }\n  });\n\n  bestFrequencies['bestAttribute'] = bestAttribute;\n  return bestFrequencies;\n}\n\n/**\n * Combines two frequency dictionaries by summing corresponding values.\n * \n * @param {Map} targetFrequencies1 - First frequency dictionary.\n * @param {Map} targetFrequencies2 - Second frequency dictionary.\n * @returns {Map} Combined frequency dictionary.\n */\nfunction combineFrequencies(targetFrequencies1, targetFrequencies2) {\n  const result = new Map(targetFrequencies1);\n  targetFrequencies2.forEach((value, key) => {\n    result.set(key, (result.get(key) || 0) + value);\n  });\n  return result;\n}\n\n/**\n * Merges similar categories in a frequency dictionary based on Bhattacharyya similarity.\n * \n * @param {Map} frequencies - Frequency dictionary with categories as keys.\n * @returns {Object} Object containing merged frequency dictionary, category-to-group mapping, and group-to-categories mapping.\n */\nfunction mergeCategories(frequencies) {\n  const categories = Array.from(frequencies.keys());\n  const categoryToGroup = new Map();\n  const groupToCategories = new Map();\n  const groupFrequencies = new Map();\n\n  for (let i = 0; i < categories.length; i++){\n\tcategory=categories[i];\n    if (categoryToGroup.has(category)) continue;\n\n    categoryToGroup.set(category, category);\n    groupToCategories.set(category, [category]);\n\n    for (let j = i + 1; j < categories.length; j++) {\n      const otherCategory = categories[j];\n      if (categoryToGroup.has(otherCategory)) continue;\n\n      const similarity = bhattacharyyaSimilarity(\n        new Float32Array(Array.from(frequencies.get(category).values())),\n        new Float32Array(Array.from(frequencies.get(otherCategory).values()))\n      );\n\n      if (similarity > 0.9) {\n        categoryToGroup.set(otherCategory, category);\n        groupToCategories.get(category).push(otherCategory);\n      }\n    }\n  };\n\n  return { groupFrequencies, categoryToGroup, groupToCategories };\n}\n\n/**\n * Calculates the frequency of each target value in a dataset.\n * \n * @param {Array<Object>} data - Dataset.\n * @param {string} target - Target variable.\n * @returns {Float32Array} Float32Array with target value frequencies.\n */\nfunction getTargetFrequencies(data, target) {\n  const targetCounts = new Map();\n  const totalCount = data.length;\n\n  data.forEach(row => {\n    const targetValue = row[target];\n    targetCounts.set(targetValue, (targetCounts.get(targetValue) || 0) + 1 / totalCount);\n  });\n\n  return new Float32Array(Array.from(targetCounts.values()));\n}\n\n/**\n * Recursively builds a decision tree.\n * \n * @param {Array<Object>} data - Dataset.\n * @param {Array<string>} attributes - Available attributes.\n * @param {string} target - Target variable.\n * @param {number} [maxDepth=3] - Maximum tree depth.\n * @param {number} [minLeaf=1] - Minimum instances per leaf.\n * @returns {Object|null} Decision tree node or null.\n */\nfunction buildTree(data, attributes, target, maxDepth = 3, minLeaf = 1) {\n  if (attributes.length === 0 || data.length === 0 || maxDepth == 0) {\n    return null;\n  }\n\n  const { bestAttribute, categoryToGroup, groupFrequencies } = findBestSplit(data, attributes, target);\n\n  if (!bestAttribute) {\n    return null;\n  }\n\n  const node = {\n    attribute: bestAttribute,\n    children: {},\n    isLeaf: true,\n    value: getTargetFrequencies(data, target),\n    categoryToGroup,\n  };\n\n  groupFrequencies.forEach((group, key) => {\n    const subset = data.filter(row => categoryToGroup.get(row[bestAttribute]) === key);\n\n    if (subset.length > minLeaf && maxDepth > 0) {\n      const child = buildTree(\n        subset,\n        attributes.filter(attr => attr !== bestAttribute),\n        target,\n        maxDepth - 1\n      );\n\n      if (child) {\n        node.children[bestAttribute + \":\" + key] = child;\n      }\n    }\n  });\n\n  node.isLeaf = Object.keys(node.children).length === 0;\n  return node;\n}\n\n/**\n * Predicts the target value for a single instance using the decision tree.\n * \n * @param {Object} tree - Decision tree.\n * @param {Object} instance - Instance to predict.\n * @returns {Float32Array|null} Predicted target value frequencies or null.\n */\nfunction predict(tree, instance) {\n  if (tree.isLeaf) {\n    return tree.value;\n  }\n\n  const attrValue = instance[tree.attribute];\n  const childNode = tree.children[tree.attribute + \":\" + tree.categoryToGroup.get(attrValue)];\n\n  if (!childNode) {\n    return null;\n  }\n\n  return predict(childNode, instance);\n}",
      "status": "[1]<br><span style=\"font-size:8px\">1ms<span></span></span>",
      "output": "",
      "type": "code"
    },
    {
      "code": "const data = [\n  { color: \"red\", shape: \"square\", label: \"A\" },\n  { color: \"blue\", shape: \"circle\", label: \"B\" },\n  { color: \"red\", shape: \"circle\", label: \"A\" },\n  { color: \"blue\", shape: \"square\", label: \"B\" },\n  { color: \"red\", shape: \"square\", label: \"A\" }\n];\n\nconst attributes = [\"color\", \"shape\"];\nconst target = \"label\";\n\nwindow.tree = buildTree(data, attributes, target, 3, 1);\n",
      "status": "[2]<br><span style=\"font-size:8px\">2ms<span></span></span>",
      "output": "{\n  \"attribute\": \"color\",\n  \"children\": {},\n  \"isLeaf\": true,\n  \"value\": {\n    \"0\": 0.6000000238418579,\n    \"1\": 0.4000000059604645\n  },\n  \"categoryToGroup\": {}\n} <br>",
      "type": "code"
    },
    {
      "code": "const instance = { color: \"red\", shape: \"square\" };\nconst prediction = predict(tree, instance);\nscrib.show(prediction);",
      "status": "[3]<br><span style=\"font-size:8px\">1ms<span></span></span>",
      "output": "{\n  \"0\": 0.6000000238418579,\n  \"1\": 0.4000000059604645\n} <br>",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/scribbler",
  "run_on_load": false
}